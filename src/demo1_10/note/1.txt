* 参考地址：https://zhuanlan.zhihu.com/p/50479555

一、时间复杂度和空间复杂度
1、时间复杂度
 公式是：T(n) = O(f(n))，「 大O符号表示法 」，其中f(n) 表示每行代码执行次数之和，而 O 表示正比例关系，这个公式的全称是：算法的渐进时间复杂度。

 先来看个例子：
 for(i=1; i<=n; ++i)
 {
    j = i;
    j++;
 }

通过「 大O符号表示法 」，这段代码的时间复杂度为：O(n) ，为什么呢?

在 大O符号表示法中，时间复杂度的公式是： T(n) = O( f(n) )，其中f(n) 表示每行代码执行次数之和，而 O 表示正比例关系，这个公式的全称是：算法的渐进时间复杂度。

我们继续看上面的例子，假设每行代码的执行时间都是一样的，我们用 1颗粒时间 来表示，那么这个例子的第一行耗时是1个颗粒时间，第三行的执行时间是 n个颗粒时间，
第四行的执行时间也是 n个颗粒时间（第二行和第五行是符号，暂时忽略），那么总时间就是 1颗粒时间 + n颗粒时间 + n颗粒时间 ，即 (1+2n)个颗粒时间，即： T(n) = (1+2n)*颗粒时间，
从这个结果可以看出，这个算法的耗时是随着n的变化而变化，因此，我们可以简化的将这个算法的时间复杂度表示为：T(n) = O(n)

为什么可以这么去简化呢，因为大O符号表示法并不是用于来真实代表算法的执行时间的，它是用来表示代码执行时间的增长变化趋势的。

所以上面的例子中，如果n无限大的时候，T(n) = time(1+2n)中的常量1就没有意义了，倍数2也意义不大。因此直接简化为T(n) = O(n) 就可以了。

常见的时间复杂度量级有：

常数阶O(1)             -------------------  可以简单理解为：变量之间的算数运算
对数阶O(logN)          -------------------  可以简单理解为：循环中有乘法的操作
线性阶O(n)             -------------------  可以简单理解为：单个for循环操作
线性对数阶O(nlogN)      -------------------  可以简单理解为：for循环嵌套while循环
平方阶O(n²)            -------------------  可以简单理解为： 两个一样的for循环嵌套
立方阶O(n³)            -------------------  可以简单理解为：多个一样的for循环嵌套
K次方阶O(n^k)          -------------------  可以简单理解为：不同的for循环嵌套
指数阶O(2^n)           -------------------  递归求斐波那契数列

上面从上至下依次的时间复杂度越来越大，执行的效率越来越低。

下面选取一些较为常用的来讲解一下（没有严格按照顺序）：
（1）常数阶O(1)
    无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是O(1)，如：
    int i = 1;
    int j = 2;
    ++i;
    j++;
    int m = i + j;
    上述代码在执行的时候，它消耗的时候并不随着某个变量的增长而增长，那么无论这类代码有多长，即使有几万几十万行，都可以用O(1)来表示它的时间复杂度。

（2）对数阶O(logN)
*********************** 对数关系描述 start ***********************
对数公式是数学中的一种常见公式，如果a^x=N(a>0,且a≠1)，则x叫做以a为底N的对数,记做x=log(a)(N)，其中a要写于log右下。其中a叫做对数的底，N叫做真数 [1]  。
通常我们将以10为底的对数叫做常用对数，以e为底的对数称为自然对数。
*********************** 对数关系描述 end   ***********************

还是先来看代码：
int i = 1;
while(i<n)
{
    i = i * 2;
}
从上面代码可以看到，在while循环里面，每次都将 i 乘以 2，乘完之后，i 距离 n 就越来越近了。我们试着求解一下，假设循环x次之后，i 就大于 2 了，
此时这个循环就退出了，也就是说 2 的 x 次方等于 n，那么 x = log2^n
也就是说当循环 log2^n 次以后，这个代码就结束了。因此这个代码的时间复杂度为：O(logn)

（3）线性阶O(n)
*********************** 线性关系描述 start ***********************
两个变量之间存在一次方函数关系，就称它们之间存在线性关系。正比例关系是线性关系中的特例，反比例关系不是线性关系。
更通俗一点讲，如果把这两个变量分别作为点的横坐标与纵坐标，其图象是平面上的一条直线，则这两个变量之间的关系就是线性关系。
即如果可以用一个二元一次方程来表达两个变量之间关系的话，这两个变量之间的关系称为线性关系，因而，二元一次方程也称为线性方程。
推而广之，含有n个变量的一次方程，也称为n元线性方程，不过这已经与直线没有什么关系了。
*********************** 线性关系描述 end   ***********************

这个在最开始的代码示例中就讲解过了，如：
for(i=1; i<=n; ++i)
{
   j = i;
   j++;
}
这段代码，for循环里面的代码会执行n遍，因此它消耗的时间是随着n的变化而变化的，因此这类代码都可以用O(n)来表示它的时间复杂度。


（4）线性对数阶O(nlogN)
线性对数阶O(nlogN) 其实非常容易理解，将时间复杂度为O(logn)的代码循环N遍的话，那么它的时间复杂度就是 n * O(logN)，也就是了O(nlogN)。

就拿上面的代码加一点修改来举例：
for(m=1; m<n; m++)
{
    i = 1;
    while(i<n)
    {
        i = i * 2;
    }
}

（5）平方阶O(n²)
平方阶O(n²) 就更容易理解了，如果把 O(n) 的代码再嵌套循环一遍，它的时间复杂度就是 O(n²) 了。
举例：

for(x=1; i<=n; x++)
{
   for(i=1; i<=n; i++)
    {
       j = i;
       j++;
    }
}
这段代码其实就是嵌套了2层n循环，它的时间复杂度就是 O(n*n)，即 O(n²)
如果将其中一层循环的n改成m，即：

for(x=1; i<=m; x++)
{
   for(i=1; i<=n; i++)
    {
       j = i;
       j++;
    }
}
那它的时间复杂度就变成了 O(m*n)


（6）立方阶O(n³)、K次方阶O(n^k)
参考上面的O(n²) 去理解就好了，O(n³)相当于三层n循环，其它的类似。
除此之外，其实还有 平均时间复杂度、均摊时间复杂度、最坏时间复杂度、最好时间复杂度 的分析方法，有点复杂，这里就不展开了。

2、空间复杂度
既然时间复杂度不是用来计算程序具体耗时的，那么我也应该明白，空间复杂度也不是用来计算程序实际占用的空间的。
空间复杂度是对一个算法在运行过程中临时占用存储空间大小的一个量度，同样反映的是一个趋势，我们用 S(n) 来定义。
空间复杂度比较常用的有：O(1)、O(n)、O(n²)，我们下面来看看：

（1）空间复杂度 O(1)
    如果算法执行所需要的临时空间不随着某个变量n的大小而变化，即此算法空间复杂度为一个常量，可表示为 O(1)
    举例：

    int i = 1;
    int j = 2;
    ++i;
    j++;
    int m = i + j;
    代码中的 i、j、m 所分配的空间都不随着处理数据量变化，因此它的空间复杂度 S(n) = O(1)

（2）空间复杂度 O(n)

  【示例1】
   我们先看一个代码：

   int[] m = new int[n]
   for(i=1; i<=n; ++i)
   {
      j = i;
      j++;
   }
   这段代码中，第一行new了一个数组出来，这个数据占用的大小为n，这段代码的2-6行，虽然有循环，但没有再分配新的空间，
   因此，这段代码的空间复杂度主要看第一行即可，即 S(n) = O(n)


   【示例2】
   现在有一个算法是这样的，给定一个数组，将数组中每个元素都乘以2返回，我实现了下面两种形式：

   private static int[] multi1(int[] array) {
       int[] newArray = new int[array.length];
       for (int i = 0; i < array.length; i++) {
           newArray[i] = array[i] * 2;
       }
       return newArray;
   }

   private static int[] multi2(int[] array) {
       for (int i = 0; i < array.length; i++) {
           array[i] = array[i] * 2;
       }
       return array;
   }
   暂且不论这两个算法孰好孰坏，你来猜猜他们的空间复杂度各是多少？

   你可能会说第一个算法的空间复杂度为O(n)，第二个算法的空间复杂度为O(1)。

   错！两个算法的空间复杂度都是O(n)。

   也不能说你完全错了，因为大部分书籍或者资料都弄错了。

   是时候了解真正的空间复杂度了。

   什么才是真正的空间复杂度？

   空间复杂度与额外空间复杂度

   空间复杂度，是指一个算法运行的过程占用的空间，这个空间包括输入参数的占用空间和额外申请的空间。

   所以，针对上面两个算法：

   第一个算法，输入参数n，额外空间n，两者相加为2n，去除常数项，空间复杂度为O(n)；

   第二个算法，输入参数n，额外空间0，两者相加为n，空间复杂度为O(n)。

   可以看到，使用空间复杂度很难判断这两个算法的好坏，所以，诞生了另一个概念——额外空间复杂度。

   额外空间复杂度，是指一个算法运行过程中额外申请的空间。

   使用额外空间复杂度，针对上面两个算法：

   第一个算法，额外空间为n，额外空间复杂度为O(n)；

   第二个算法，额外空间为0，额外空间复杂度为O(1)；

   似乎没见过有O(0)这种写法。

   可以看到，使用额外空间复杂度能够很轻易地判断两个算法的好坏（从空间占用的角度）。

   所以，是时候纠正错误的概念了，以后与人交流的时候请使用“额外空间复杂度”这个概念。
